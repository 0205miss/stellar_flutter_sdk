import 'package:http/http.dart' as http;
import '../0001/stellar_toml.dart';
import 'dart:async';
import '../../requests/request_builder.dart';
import '../../responses/response.dart';
import '../../util.dart';
import '../0009/standard_kyc_fields.dart';

/// Implements SEP-0012 - KYC API.
/// See <https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0012.md" target="_blank">KYC API</a>
class KYCService {
  String _serviceAddress;

  KYCService(String serviceAddress) {
    serviceAddress =
        checkNotNull(serviceAddress, "serviceAddress cannot be null");
  }

  static Future<KYCService> fromDomain(String domain) async {
    checkNotNull(domain, "domain cannot be null");
    StellarToml toml = await StellarToml.fromDomain(domain);
    String addr = toml.generalInformation.kYCServer;
    if (addr == null) {
      addr = toml.generalInformation.transferServer;
    }
    return new KYCService(addr);
  }

  /// Check the status of a customers info (customer GET)
  /// This endpoint allows clients to:
  // 1. Fetch the fields the server requires in order to register a new customer:
  // If the server does not have a customer registered for the parameters sent in the request, it will return the fields required in the response. The same response will be returned when no parameters are sent.
  // 2. Check the status of a customer that may already be registered
  // This allows clients to check whether the customers information was accepted, rejected, or still needs more info. If the server still needs more info, or the server needs updated information, it will return the fields required.
  Future<GetCustomerInfoResponse> getCustomerInfo(
      GetCustomerInfoRequest request) async {
    checkNotNull(request, "request cannot be null");
    Uri serverURI = Uri.parse(_serviceAddress + "/customer");
    http.Client httpClient = new http.Client();

    _GetCustomerInfoRequestBuilder requestBuilder =
        new _GetCustomerInfoRequestBuilder(httpClient, serverURI);

    final Map<String, String> queryParams = {};

    if (request.id != null) {
      queryParams["id"] = request.id;
    }
    if (request.account != null) {
      queryParams["account"] = request.account;
    }
    if (request.memo != null) {
      queryParams["memo"] = request.memo;
    }
    if (request.memoType != null) {
      queryParams["memo_type"] = request.memoType;
    }
    if (request.type != null) {
      queryParams["type"] = request.type;
    }
    if (request.lang != null) {
      queryParams["lang"] = request.lang;
    }

    GetCustomerInfoResponse response = await requestBuilder
        .forQueryParameters(queryParams)
        .execute(request.jwt);

    return response;
  }

  Future<PutCustomerInfoResponse> putCustomerInfo(
      PutCustomerInfoRequest request) async {
    checkNotNull(request, "request cannot be null");
    Uri serverURI = Uri.parse(_serviceAddress + "/customer");
    http.Client httpClient = new http.Client();

    _PutCustomerInfoRequestBuilder requestBuilder =
        new _PutCustomerInfoRequestBuilder(httpClient, serverURI);

    final Map<String, String> queryParams = {};

    if (request.id != null) {
      queryParams["id"] = request.id;
    }
    if (request.account != null) {
      queryParams["account"] = request.account;
    }
    if (request.memo != null) {
      queryParams["memo"] = request.memo;
    }
    if (request.memoType != null) {
      queryParams["memo_type"] = request.memoType;
    }
    if (request.type != null) {
      queryParams["type"] = request.type;
    }

    // TODO kYC Fields

    PutCustomerInfoResponse response = await requestBuilder
        .forQueryParameters(queryParams)
        .execute(request.jwt);

    return response;
  }
}

class GetCustomerInfoRequest {
  /// (optional) The ID of the customer as returned in the response of a previous PUT request. If the customer has not been registered, they do not yet have an id.
  String id;

  /// (optional) The Stellar account ID used to identify this customer. If many customers share the same Stellar account, the memo and memo_type parameters should be included as well.
  String account;

  /// (optional) a properly formatted memo that uniquely identifies a customer. This value is generated by the client making the request. This parameter and memo_type are identical to the PUT request parameters of the same name.
  String memo;

  /// (optional) type of memo. One of text, id or hash. If hash, memo should be base64-encoded.
  String memoType;

  /// (optional) the type of action the customer is being KYCd for. See the Type Specification here:
  /// https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0012.md#type-specification
  String type;

  /// (optional) Defaults to en. Language code specified using ISO 639-1. Human readable descriptions, choices, and messages should be in this language.
  String lang;

  /// jwt previously received from the anchor via the SEP-10 authentication flow
  String jwt;
}

/// The CustomerInfoFields object defines the pieces of information the anchor has not yet received for the customer. It is required for the NEEDS_INFO status but may be included with any status.
/// Fields should be specified as an object with keys representing the SEP-9 field names required.
/// Customers in the ACCEPTED status should not have any required fields present in the object, since all required fields should have already been provided.
class GetCustomerInfoFields extends Response {
  /// The data type of the field value. Can be "string", "binary", "number", or "date".
  String type;

  /// A human-readable description of this field, especially important if this is not a SEP-9 field.
  String description;

  /// (optional) An array of valid values for this field.
  List<String> choices;

  /// (optional) A boolean whether this field is required to proceed or not. Defaults to false.
  bool optional;

  GetCustomerInfoFields(
      this.type, this.description, this.choices, this.optional);

  factory GetCustomerInfoFields.fromJson(Map<String, dynamic> json) =>
      new GetCustomerInfoFields(
          json['type'] as String,
          json['description'] as String,
          json['choices'] == null
              ? null
              : new List<String>.from(json['choices']),
          json['optional'] as bool);
}

/// The provided CustomerInfoProvidedFields object defines the pieces of information the anchor has received for
/// the customer. It is not required unless one or more of provided fields require verification
/// via customerVerification.
class GetCustomerInfoProvidedFields extends Response {
  /// The data type of the field value. Can be "string", "binary", "number", or "date".
  String type;

  /// A human-readable description of this field, especially important if this is not a SEP-9 field.
  String description;

  /// (optional) An array of valid values for this field.
  List<String> choices;

  /// (optional) A boolean whether this field is required to proceed or not. Defaults to false.
  bool optional;

  /// (optional) One of the values described here: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0012.md#field-statuses
  /// If the server does not wish to expose which field(s) were accepted or rejected, this property will be omitted.
  String status;

  /// (optional) The human readable description of why the field is REJECTED.
  String error;

  GetCustomerInfoProvidedFields(this.type, this.description, this.choices,
      this.optional, this.status, this.error);

  factory GetCustomerInfoProvidedFields.fromJson(Map<String, dynamic> json) =>
      new GetCustomerInfoProvidedFields(
        json['type'] as String,
        json['description'] as String,
        json['choices'] == null ? null : new List<String>.from(json['choices']),
        json['optional'] as bool,
        json['status'] as String,
        json['error'] as String,
      );
}

/// Represents a customer info request response.
class GetCustomerInfoResponse extends Response {
  /// (optional) ID of the customer, if the customer has already been created via a PUT /customer request.
  String id;

  /// Status of the customers KYC process.
  String status;

  /// (optional) An object containing the fields the anchor has not yet received for the given customer of the type provided in the request. Required for customers in the NEEDS_INFO status. See Fields for more detailed information.
  GetCustomerInfoFields fields;

  /// (optional) An object containing the fields the anchor has received for the given customer. Required for customers whose information needs verification via customerVerification.
  GetCustomerInfoProvidedFields providedField;

  /// (optional) Human readable message describing the current state of customer's KYC process.
  String message;

  GetCustomerInfoResponse(
      this.id, this.status, this.fields, this.providedField, this.message);

  factory GetCustomerInfoResponse.fromJson(Map<String, dynamic> json) =>
      new GetCustomerInfoResponse(
          json['id'] as String,
          json['status'],
          json['fields'] == null
              ? null
              : new GetCustomerInfoFields.fromJson(
                  json['fields'] as Map<String, dynamic>),
          json['provided_fields'] == null
              ? null
              : new GetCustomerInfoProvidedFields.fromJson(
                  json['provided_fields'] as Map<String, dynamic>),
          json['message']);
}

// Requests the customer info data.
class _GetCustomerInfoRequestBuilder extends RequestBuilder {
  _GetCustomerInfoRequestBuilder(http.Client httpClient, Uri serverURI)
      : super(httpClient, serverURI, null);

  _GetCustomerInfoRequestBuilder forQueryParameters(
      Map<String, String> queryParams) {
    queryParameters.addAll(queryParams);
    return this;
  }

  static Future<GetCustomerInfoResponse> requestExecute(
      http.Client httpClient, Uri uri, String jwt) async {
    TypeToken type = new TypeToken<GetCustomerInfoResponse>();
    ResponseHandler<GetCustomerInfoResponse> responseHandler =
        new ResponseHandler<GetCustomerInfoResponse>(type);

    final Map<String, String> feeHeaders = RequestBuilder.headers;
    if (jwt != null) {
      feeHeaders["Authorization"] = "Bearer $jwt";
    }
    return await httpClient.get(uri, headers: feeHeaders).then((response) {
      return responseHandler.handleResponse(response);
    });
  }

  Future<GetCustomerInfoResponse> execute(String jwt) {
    return _GetCustomerInfoRequestBuilder.requestExecute(
        this.httpClient, this.buildUri(), jwt);
  }
}

class PutCustomerInfoRequest {
  /// (optional) The id value returned from a previous call to this endpoint. If specified, no other parameter is required.
  String id;

  /// (optional) The Stellar account ID to upload KYC data for. If specified, id should not be specified.
  String account;

  /// (optional) Uniquely identifies individual customers in schemes where multiple customers share one Stellar address (ex. SEP-31). If included, the KYC data will only apply to all requests that include this memo.
  String memo;

  /// (optional) type of memo. One of text, id or hash. If hash, memo should be base64-encoded.
  String memoType;

  /// (optional) the type of action the customer is being KYCd for. See the Type Specification here:
  /// https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0012.md#type-specification
  String type;

  StandardKYCFields kycFields;

  /// jwt previously received from the anchor via the SEP-10 authentication flow
  String jwt;
}

/// Represents a put customer info request response.
class PutCustomerInfoResponse extends Response {
  /// An identifier for the updated or created customer.
  String id;

  PutCustomerInfoResponse(this.id);

  factory PutCustomerInfoResponse.fromJson(Map<String, dynamic> json) =>
      new PutCustomerInfoResponse(json['id'] as String);
}

// Puts the customer info data.
class _PutCustomerInfoRequestBuilder extends RequestBuilder {
  _PutCustomerInfoRequestBuilder(http.Client httpClient, Uri serverURI)
      : super(httpClient, serverURI, null);

  _PutCustomerInfoRequestBuilder forQueryParameters(
      Map<String, String> queryParams) {
    queryParameters.addAll(queryParams);
    return this;
  }

  static Future<PutCustomerInfoResponse> requestExecute(
      http.Client httpClient, Uri uri, String jwt) async {
    TypeToken type = new TypeToken<PutCustomerInfoResponse>();
    ResponseHandler<PutCustomerInfoResponse> responseHandler =
        new ResponseHandler<PutCustomerInfoResponse>(type);

    final Map<String, String> feeHeaders = RequestBuilder.headers;
    if (jwt != null) {
      feeHeaders["Authorization"] = "Bearer $jwt";
    }
    return await httpClient.put(uri, headers: feeHeaders).then((response) {
      return responseHandler.handleResponse(response);
    });
  }

  Future<PutCustomerInfoResponse> execute(String jwt) {
    return _PutCustomerInfoRequestBuilder.requestExecute(
        this.httpClient, this.buildUri(), jwt);
  }
}
